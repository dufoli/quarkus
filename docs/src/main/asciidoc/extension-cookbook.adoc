////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Extension Cookbook

:numbered:
:sectnums:
:sectnumlevels: 4
:toc:

include::./attributes.adoc[]

== Context & Objective

The purpose of this cookbook is to explain for extension developer, a step by step process to build an extension from scratch.
Other guide are API oriented and this one will not detailed API. For this purpose use other guides such as :
- link:writing-extensions.html[Write Your Own Extension] 
- link:writing-native-applications-tips.html[Tips for writing native applications]
- link:building-my-first-extension.html[Build My first extension]

So this guide will not detail how to generate BuildItem or use substitution, but it will explain the workflow to handle extension.
First an extension is a module which will be run by Quarkus during build time (pre-compilation) to generate code and include it into the compiled package.

== Organisation

There are 2 projects:
- **runtime**:: Contains all classes loaded during runtime
- **deployment**:: Contains all processor classes which will be run during the build.

The processor is the heart of the extension all build step methods are a hierarchy of dependant.
Quarkus automatically detect build items input and output and run then in the right order.
It mean that sometimes, a build Item unused is added in order to force order of execution of build step after the generation of the unused input.

The processor can generate bytecode, read config, and pass some data to runtime thanks to recorder (only simple structure).

== JVM : containerization

Quarkus run inside a container, and the container handle the CDI and all injected beans.
So it means that processor must generate a producer of client, register servlet or route http request to backend.
In order to do this stuff, there are 2 inputs:

- configuration: build time and runtime configs must been splited.
- jandex (CombinedIndexBuildItem) give access to reflection during build time.


=== Injectable client bean (config, producer)

BuildStep can generate a producer with Gizmo :
```
private void generateMyClientProducer(BuildProducer<GeneratedBeanBuildItem> generatedBean) {
    ClassOutput classOutput = new GeneratedBeanGizmoAdaptor(generatedBean);

    try (ClassCreator classCreator = ClassCreator.builder().classOutput(classOutput)
            .className("MyProducer")
            .build()) {
            //here generate your client generation method with Produces annotation
    }
}
```
Synthetic build item is another option.

Paid attention to split config for buildtime (can not been changed on runtime) and for runtime (not known during buildtime).

=== Configure the runtime beans

If you need to send data from build time to runtime to configure bean, you can use recorder to send simple data (String, List,...).
For hierarchy, there is a trampoline process in Runtime buildstep:
```
@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
public void build(CustomRecorder recorder, List<ComplexeBuildItem> complexeBuildItems) {
    // for hierarchy create a tree and get back runtimeValue
    RuntimeValue<ComplexConfig> complexConfig = recorder.createComplexConfig();
    for (ComplexeBuildItem complexeBuildItem : complexeBuildItems) {
        // then send leaf to add to tree
        recorder.registerLeaf(complexConfig, complexeBuildItem.getString());
    }
    // use complexe config for a beans
    recorder.startBean(complexConfig);
}
```

On recoder:
```
@Recorder
public class CustomRecorder {
    public RuntimeValue<ComplexConfig> createComplexConfig() {
        return new RuntimeValue<>(new ComplexConfig());
    }
    public void registerLeaf(RuntimeValue<ComplexConfig> complexConfig, String cfg) {
        ComplexConfig complexConfigValue = complexConfig.getValue();
        complexConfigValue.add(cfg);
    }
    public void startBean(RuntimeValue<ComplexConfig> complexConfig) {
        // start on runtime part
    }
}
```
=== Register servlet

Build step can generate the ServletBuildItem which point to the servlet class.
But vert.x routes must be the prefered solution because vertx route use reactor design pattern for high availability.

=== Route vertx

BuildStep must produce a RouteBuildItem with an Handler<RoutingContext> class as parameter.

=== Removable
Quarkus cleanup unused beans. So if you need to register a bean for injection but load without inject (CDI.current().select(MyClient.class).get())
There are 3 way to do it:

- Unremovable annotation on bean class (not for synthetic beans)
- processor can produce UnremovableBeanBuildItem with the className of the bean
- processor can produce AdditionalBeanBuildItem.unremovableOf()

== Native

If you have followed previous steps, Quarkus container can manage client injection.
Now it is time to work on native and that is the hard part because of all limitation of Graal native mode.

- Dynamic class loading (and method invoke, field access) must be declared by a processor
- Dynamic proxy must be declared by the processor
- Dynamic generation of ASM is not possible so must be generate during build time (Gizmo)
- static init is run during build time for native. Some class (which use thread or environment) have to be delayed to runtime.
...

https://www.graalvm.org/reference-manual/native-image/Limitations/

=== Reflection
Search full text on "Class.forName" and "loadClass" and "getMethod" on the source of module.
Create a buildStep with the list of class ReflectiveClassBuildItem
set methods ReflectiveClassBuildItem parameter to true if getMethod is used and false for other.
Same process occure for fields which are used with reflection and constructor so paid attention to set ReflectiveClassBuildItem parameter to true for this kind of usage.

=== ASM emit
Search full text for "org.objectweb.asm" or "ClassWriter" and translate all generated class process to gizmo generation.
==> BuildStep with input BuildProducer<GeneratedBeanBuildItem> generatedBeans
and ClassOutput classOutput = new GeneratedBeanGizmoAdaptor(generatedBeans);

=== MethodHandle
MethodHandle is not supported  currently in graal. It must been suported in next released and quarkus will provide a way to regeister them.
But the current solution is to use substitution to replace MethodHandle with Method.invoke();

=== Proxy
Search full text for "newProxyInstance". For each usage, register interface(s) used for proxy on a processor with NativeImageProxyDefinitionBuildItem.

=== Resources
Get list of resources present in the jar and produce a NativeImageResourceBuildItem for each one.
For hierarchy of dependency, duplicate resource file name can been on different jar but the native package can not contain resource file with same name. So merge of file can be needed.

=== Runtime load
For this part, you have to run and if you see an error from graalvm saying that a particular class must be loaded on runtime and not static init.
It comme from a static init of a source class which load a class only available on runtime (thread for example).
Goal is to find the source class with the static init and not the target.
First, you must add a property to the project on native profile.
<quarkus.native.additional-build-args>-H:+TraceClassInitialization</quarkus.native.additional-build-args>
<reportErrorsAtRuntime>true</reportErrorsAtRuntime>
Start a new build with this parameter will give you the source class.
Then you have to register in the extension processor a RuntimeInitializedClassBuildItem.

== JVM : inject class emitted in classLoader and remove substitution

Finally, the goal is to load class produce for native part on jvm too. In order to speed up boot time and simplify maintainance by having same code between native and jvm at maximum.
Try to reduce substitution to minimum.
On native, you can inject code thanks to substitution.
But on jvm part, to avoid code generation, the class generated during build time can not always replace the original one.
So, a merge request must been provided to maintainer of source project to add the ability to inject class emitted by Quarkus during augmentation to replace asm generation classes.

== Debugging

class dump : mvn quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes

build jvm : mvn clean install

build native : mvn clean install -Dnative

fullstacktrace: -DtrimStackTrace=false
